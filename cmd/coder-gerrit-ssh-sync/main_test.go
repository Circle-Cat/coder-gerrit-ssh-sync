package main

import (
	"context"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"
)

func TestCoderGet(t *testing.T) {
	ctx := context.Background()

	testCases := []struct{
		name         string
		mockResponse func(w http.ResponseWriter, r *http.Request)
		expected     coderBuildInfoResponse
		expectedErr  string
		inputPath    string
	}{
		{
			// Scenario 1: Return version successfully
			name: "Successful response",
			mockResponse: func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(http.StatusOK) // set HTTP 200 means success.
				fmt.Fprintln(w, `{"Version": "1.0.0"}`) // writes data to w, mimic return file from the server.
			},
			expected: coderBuildInfoResponse{Version: "1.0.0"},
			expectedErr: "",
			inputPath: "/api/v2/buildinfo",
		},
		{
			// Scenario 2: if server was reached and understood the request, but can't find resource to return (invalid path)
			name: "Not found 404 error",
			mockResponse: func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(http.StatusNotFound) // 404 means requested resources not found on server
			},
			expected: coderBuildInfoResponse{},
			expectedErr: "Coder HTTP status: 404 Not Found",
			inputPath: "/api/v2/invalidPath",
		},
		{
            // Scenario 3: if server was reach and understood the request, but fail to return the Version.
            // Decode will return "invalid character '}' looking for beginning of value" automatically
            name: "Failed to return Version in JSON",
            mockResponse: func(w http.ResponseWriter, r *http.Request) {
                w.WriteHeader(http.StatusOK)
                fmt.Fprintln(w, `{"Version":}`) // Version empty will trigger invalid character'}'
            },
            expected: coderBuildInfoResponse{},
            expectedErr: "invalid character '}' looking for beginning of value",
            inputPath: "/api/v2/buildinfo",
        },
		{
			// Scenario 4: Invalid URL error
			name: "Invalid URL error",
			mockResponse: func(w http.ResponseWriter, r *http.Request) {
			},
			expected:    coderBuildInfoResponse{},
			expectedErr: "parse \"http://:%22/api/v2/buildinfo\": invalid port \":%22\" after host",
			inputPath:   "/api/v2/buildinfo",
		},
		{
			// Scenario 5: Unreachable address error
			name: "Unreachable address error",
			mockResponse: func(w http.ResponseWriter, r *http.Request) {
			},
			expected:    coderBuildInfoResponse{},
			expectedErr: "dial tcp 192.0.2.1:80: connect: network is unreachable",
			inputPath:   "/api/v2/buildinfo",
		},

	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			
			// Create a mock HTTP server
            // httptest.NewServer: set up local HTTP server for testing specific. Runs locally doesn't need internet access.
			// http.HandlerFunc(tc.mockResponse) wraps tc.mockResponse into http.Handler interface, which is what httptest want. httptest can automatically input http.ResponseWriter and *http.Request
			server := httptest.NewServer(http.HandlerFunc(tc.mockResponse))
			defer server.Close()

			var client *coderClient
			if tc.name == "Invalid URL error" {
				// Use invalid URL
				client = newCoderClient("http://:%22", "test-token")
			} else if tc.name == "Unreachable address error" {
				// Use unreachable URL
				client = newCoderClient("http://192.0.2.1", "test-token")
			} else {
				// Create a test coderClient.
				// server.URL is generated by httptest automatically
				client = newCoderClient(server.URL, "test-token")
			}

			// Test request
			var bi coderBuildInfoResponse
			err := client.get(ctx, tc.inputPath, &bi)

			// Check error matches
			if err != nil && tc.expectedErr == "" {
				t.Fatalf("Unexpected error: %v", err) // break immediately 
			}
			if err == nil && tc.expectedErr != "" {
				t.Fatalf("Expected error but got none") // break immediately 
			}

			// Check response
			if bi.Version != tc.expected.Version {
				t.Errorf("Expected version '%s', got '%s'", tc.expected.Version, bi.Version) // print the error but not break
			}

		})
	}
}
